---
title: kubevirtci-image-init-script（workinprocess）
readmore: true
date: 2022-07-19 12:40:13
categories: 云原生
tags:
- KubeVirt CI
---


virt-sysprep 初始化镜像有时候不完全满足需求，需要额外初始化步骤。virt-sysprep执行后，往往还需要执行些脚本辅助清理初始化工作。

virt-sysprep参考 {% post_link kubevirtci-virt-sysprep %} 

## 清理 bash-history
```bash
#!/usr/bin/env bash
#
# Remove bash history for root and system users
set -o errexit

roots_hist="$(find /root -type f -name .bash_history)"
users_hist="$(find /home -type f -name .bash_history | tr -s '\n' ' ')"

rm -f ${roots_hist} ${users_hist}

exit 0
```
> root只有一个，user往往有多个，将换行替换成空格作为rm命令的参数

## 清理 cloud-init
```bash
#!/usr/bin/env bash
#
# Remove all cloud-init run-time data and logs
#
# The removal completely resets cloud-init. When the instance is next
# started cloud-init will run all configured modules as if running for the
# first time
set -o errexit

rm -rf /var/lib/cloud/*
rm -f /var/log/cloud-init.log

exit 0
```

## 清理系统崩溃的dump数据
```bash
#!/usr/bin/env bash
#
# Remove crash data generated by kexec-tools
set -o errexit

crash_data_location=(
    "/var/crash/*"
    "/var/log/dump/*"
)

# Include hidden files in glob
shopt -s nullglob dotglob

for crash_data in ${crash_data_location[@]}
do
    rm -rf ${crash_data}
done

exit 0
```
> `shopt -s nullglob dotglob`为了`rm -rf *`可以包含隐藏文件

# 清理dhcp-client数据
```bash
#!/usr/bin/env bash
#
# Remove DHCP client lease information. Note that Debian 10, and possibly
# other OSes, now write a machine specific DUID (DHCP Unique ID) to the
# leases file
set -o errexit

lease_data_locations=(
    "/var/lib/dhclient/*"
    "/var/lib/dhcp/*"
)

# Include hidden files in glob
shopt -s nullglob dotglob

# Ensure all interfaces are down prior to removing the leases file.
# Otherwise the file is recreated by ifdown/dhclient
for iface in $(ls /sys/class/net/ | grep -v lo); do
    # Wait for each interface to be taken down. Timeout after 20 secs
    timer=0
    while grep up "/sys/class/net/${iface}/operstate" &>/dev/null && \
        [[ timer -lt 20 ]]; do
        sleep 1
        let timer=${timer}+1
    done

    # If the interface is still up it is likely something has gone wrong
    # with the usual procedures that take the interface down at shutdown.
    # Make a best effort attempt to take the interface down manually
    # temporarily ignoring errors
    if grep up "/sys/class/net/${iface}/operstate" &>/dev/null; then
        set +o errexit
        ifdown ${iface}
        set -o errexit
    fi

    # Some implementations start the dhcp client when the interface is taken
    # down (even if the interface is statically configured). It is the dhcp
    # client that writes out to the leases file when the interface goes
    # down. Kill the client as a precautionary measure to prevent further
    # interference. Ignore errors in case the dhclient exits between
    # obtaining its pid and killing it
    pid="$(ps aux | grep /sbin/dhclient | grep "${iface}" | tr -s " " | \
        cut -d' ' -f2)"
    if [ "x${pid}" != "x" ]; then
        set +o errexit
        kill -9 "${pid}"
        set -o errexit
    fi
done

# Now that all interfaces are down remove all lease files
for lease_file in ${lease_data_locations[@]}; do
    rm -f ${lease_file}
done

exit 0
```
> 设定timeout为20秒，等待interface down，若还没down则通过ifdown命令down掉，网口down的时候可能dhcpclient会起进程，kill掉对应网口的dhcpclient进程后进入清理文件的工作。

## 清理防火墙规则和配置
```bash
#!/usr/bin/env bash
#
# Remove any custom firewall rules or firewalld configuration
#
# Modern systems typically make use of the dynamic firewall daemon
# firewalld which provides many advantages and additional features over
# more traditional approaches. Customisation of the systems firewall rules
# it handled through user space tools that output configuration
# customisations to /etc/firewalld/zones and /etc/firewalld/services.
# Deleting these files will remove any custom configuration from the
# system
#
# Older systems or other firewall implementations usually persist rules
# information for iptables in /etc/sysconfig/iptables and use the file to
# configure the firewall at startup. As such simply deleting the file will
# be enough to remove any custom configuration from the system
set -o errexit

fw_config_locations=(
    "/etc/sysconfig/iptables"
    "/etc/firewalld/services/*"
    "/etc/firewalld/zones/*"
)

# If using firewalld stop the daemon/service prior to removing the config
if command -v systemctl &>/dev/null; then
    if systemctl is-active firewalld.service &>/dev/null; then
        systemctl stop firewalld.service
    fi
fi

# Include hidden files in globs
shopt -s nullglob dotglob

# Remove any custom configuration
for fw_config in ${fw_config_locations[@]}
do
    rm -rf ${fw_config}
done

exit 0
```
> `command -v systemctl`检查是否存在systemctl命令。整个脚本先停掉防火墙服务，然后清理相关文件。


## 清理日志
```bash
#!/usr/bin/env bash
#
# Remove log files from the guest
#
# Basic outline for treatment of log directories:
# 1. Section 1 of 'log directories' loop:
#    Create a tmpfs file system and copy any existing files from the log
#    directory to the new file system
# 2. Section 2 of 'log directories' loop:
#    Mount the tmpfs file system over the top of the existing on-disk log
#    files directory. This *hopefully* means than any process relying on
#    files in the log directory will still have access to them and will
#    allow a clean shutdown while still allowing removal of all on disk
#    log files.
#    Since tmpfs file systems live on memory the contents copied to them
#    will disappear on shutdown
# 3. Section 3 of 'log directories' loop:
#    Once the tmpfs file system has been mounted the original on-disk log
#    directory will no longer be directly accessible. In order to access
#    and clear any log files from these disk areas we need to re-mount or
#    bind mount the device or file system on which the log directory is
#    residing to an alternate location. We can then access and remove
#    any files from the disk by doing so from the alternate mount point.
#
# Static log files are removed directly at the end of the script
#
# Original log list taken from Libguestfs's sysprep_operation_logfiles.ml
# See https://github.com/libguestfs/libguestfs/tree/master/sysprep
set -o errexit

# Absolute path to guest log file directories
# All files under the given directories will be removed
logd_locations=(
  # Log files and directories
  "/var/log"

  # GDM and session preferences
  "/var/cache/gdm"
  "/var/lib/AccountService/users"

  # Fingerprint service files
  "/var/lib/fprint"

  # fontconfig caches
  "/var/cache/fontconfig"

  # man pages cache
  "/var/cache/man"
)

# Absolute path to static log files that can be removed directly
logf_locations=(
  # Logfiles configured by /etc/logrotate.d/*
  "/var/named/data/named.run"
  # Status file of logrotate
  "/var/lib/logrotate.status"

  # Installation files
  "/root/install.log"
  "/root/install.log.syslog"
  "/root/anaconda-ks.cfg"
  "/root/original-ks.cfg"
  "/root/anaconda-post.log"
  "/root/initial-setup-ks.cfg"

  # Pegasus certificates and other files
  "/etc/Pegasus/*.cnf"
  "/etc/Pegasus/*.crt"
  "/etc/Pegasus/*.csr"
  "/etc/Pegasus/*.pem"
  "/etc/Pegasus/*.srl"
)


# Set mountpoint used to access original on disk content
mntpnt_orig_logd="/mnt/orig_log_dir"

# Include hidden files in glob
shopt -s dotglob

# Since the current contents of the log directories will essentially be
# copied into memory, we need to ensure that we don't cause an out of
# memory condition for the guest. The limit of 128m should be extremely
# generous for most systems
sum_logd_space=0
for logd in ${logd_locations[@]}
do
    if [ -d ${logd} ]; then
        logd_space="$(du -sm ${logd} | cut -f1)"
    else
        logd_space=0
    fi
    sum_logd_space=$(( ${sum_logd_space} + ${logd_space} ))
    if [ ${sum_logd_space} -gt 128 ]; then
        echo "ERROR: Space for copying logs into memory > 128mb. Exiting"
        exit 1
    fi
done

# Test for tmpfs filesystem at /dev/shm creating one if it doesn't exist
# If /dev/shm is not present, attempt to create it
if ! mount -l -t tmpfs | grep /dev/shm &>/dev/null; then
    [[ -d /dev/shm ]] || mkdir /dev/shm && chmod 1777 /dev/shm
    mount -t tmpfs -o defaults,size=128m tmpfs /dev/shm
fi

# Remove logs from given log directories
for logd in ${logd_locations[@]}
do
    if [ -d ${logd} ]; then
        # Test if the path or its parents are already on tmpfs
        logd_path="${logd}"
        on_tmpfs=false

        while [[ ${logd_path:0:1} = "/" ]] && [[ ${#logd_path} > 1 ]] && \
              [[ ${on_tmpfs} = false ]]
        do
            defifs=${IFS}
            IFS=$'\n' # Set for convenience with mount output
            for mountpoint in $(mount -l -t tmpfs | cut -d' ' -f3)
            do
                if [ "${mountpoint}" == "${logd_path}" ]; then
                    on_tmpfs=true
                    continue # No need to test further
                fi
            done
            IFS=${defifs} # Restore the default IFS and split behaviour
            logd_path=${logd_path%/*} # Test parent on next iteration
        done

        if [ "${on_tmpfs}" = false ]; then
            # Initialise/reset var used to store where log dir is located
            logd_located_on=""
            # If log directory is a mounted partition we need the device
            defifs=${IFS} && IFS=$'\n' # Set for convenience with df output
            for line in $(df | tr -s ' ')
            do
                # Sixth column of df output is the mountpoint
                if echo ${line} | cut -d' ' -f6 | grep ^${logd}$ &>/dev/null; then
                    # First column of df output is the device
                    logd_located_on="$(echo ${line} | cut -d' ' -f1)"
                fi
            done
            IFS=${defifs} # Restore the default IFS and split behaviour
            # If the log directory is not a mounted partition it must be on
            # the root file system
            [[ "x${logd_located_on}" = "x" ]] && logd_located_on="/"


            # Recreate the log directory under /dev/shm (on tmpfs)
            shmlogd="/dev/shm/${logd}"
            mkdir -p ${shmlogd}
            chmod 1777 ${shmlogd}
            # Copy all files from original log dir to new tmpfs based dir
            files=(${logd}/*) # Array allows wildcard/glob with [[ test ]]
            [[ -e ${files} ]] && cp -pr ${logd}/* ${shmlogd}
            # Replace the original disk based log directory structure with
            # the ephemeral tmpfs based storage by mounting it over the top of
            # the original log directories location on the file system
            mount --bind ${shmlogd} ${logd}


            # Create a mount point from which the contents of the original
            # on-disk log directory can be accessed post mount of the tmpfs
            # file system
            mkdir ${mntpnt_orig_logd}
            # Mount or bind mount in order to access the original on disk logs
            if [ ${logd_located_on} = "/" ]; then
                # Temp file system is a folder on the root file system
                mount_opts="--bind"
                # Contents will be under mount point + original path e.g
                # /mountpoint/var/tmp
                logd_path="${mntpnt_orig_logd}/${logd}"
            else
                # Temp file system is a disk partition
                mount_opts=""
                # Contents will be directly available under the mount point
                logd_path="${mntpnt_orig_logd}"
            fi
            # Mount the device holding the temp file system or bind mount the
            # root file system
            mount ${mount_opts} ${logd_located_on} ${mntpnt_orig_logd}
            # The lastlog file cannot be created on demand for some reason
            # and errors occur if /var/log/lastlog is missing. So, check if
            # '/var/log/lastlog' exists and store the location so we can
            # recreate later
            if [ "${logd}" == "/var/log" ]; then
                lastlog="$(find ${logd_path} -type f -name lastlog)"
            fi
            # Delete all files from the on-disk log directory
            find "${logd_path}" -type f | xargs -I FILE rm -f FILE
            # Recreate the /var/log/lastlog file if required
            if [[ "${logd}" == "/var/log" ]] && [[ "x${lastlog}" != "x" ]]; then
                touch "${lastlog}"
            fi
            # Cleanup
            umount ${mntpnt_orig_logd} && rm -rf ${mntpnt_orig_logd}
        fi
    fi
done

# Remove static log files and files that may be removed directly
for file in ${logf_locations[@]}
do
    [[ -e ${file} ]] && rm -f ${file}
done


exit 0
```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```
